import {
	asciiFont,
	getPackageRepoUrlFromContent,
	joinPath,
	joinUrl,
} from '@dovenv/core/utils'

import {
	pkgBadges,
	socialBadges,
} from './utils'

import type { PackageJSON } from '@dovenv/core/utils'

export type ConstsConfig = {
	/**
	 * Workspace Package JSON object for use in `dovenv` configuration.
	 *
	 * @example
	 * import { getCurrentDir, joinPath, getObjectFromJSONFile } from '@dovenv/core/utils'
	 * const workspaceDir = joinPath( getCurrentDir( import.meta.url ), '../../../../' )
	 * const pkg = await getObjectFromJSONFile( joinPath( workspaceDir, 'package.json' ) )
	 * @example
	 * import { getWorkspaceConfig } from '@dovenv/theme-pigeonposse'
	 * const { pkg } = await getWorkspaceConfig({metaURL: import.meta.url, path: '../../../../'} )
	 */
	pkg?          : PackageJSON
	/**
	 * Workspace directory for use in `dovenv` configuration.
	 */
	workspaceDir? : string
	/**
	 * Packages directory for use in `dovenv` configuration.
	 *
	 *  @default
	 * join( this.workspaceDir, 'packages')
	 */
	packagesDir?  : string
	/**
	 * Main Library Package JSON object.
	 *
	 * @default this.pkg
	 */
	corePkg?      : PackageJSON
	/**
	 * Main lib directory for use in `dovenv` configuration.
	 *
	 * @default this.workspaceDir
	 */
	coreDir?      : string
}

export const getPigeonposseData = ( params: ConstsConfig = {} ): Record<string, unknown> => {

	const pkg = params.pkg as ( PackageJSON )

	if ( !pkg || typeof pkg !== 'object' ) return {}

	const {
		workspaceDir,
		corePkg = pkg,
		coreDir = params?.workspaceDir || '',
		packagesDir = joinPath( params?.workspaceDir || '', 'packages' ),
	} = params

	const name = pkg.extra?.productName || pkg.extra?.id || corePkg.name || pkg.name || ''

	const processPeople = ( people?: PackageJSON['contributors'] ) =>
		people?.filter( person =>
			typeof person === 'object'
			&& 'name' in person
			&& person.name
			&& 'url' in person,
		).map( person =>
			// @ts-ignore
			`[${person.name}](${person.url || '#'})`,
		).join( ', ' ) || ''

	const mark = async () => `
${await asciiFont( pkg.extra?.collective?.id ? `${pkg.extra.collective.id}\n-------\n${name}` : name, 'ANSI Shadow' )}
- Author: [${pkg.author?.name}](${pkg.author?.url || '#'})
${pkg.contributors?.length
		? ` - Contributors: ${processPeople( pkg.contributors )}`
		: ''
}
${pkg.maintainers?.length
		? ` - Maintainers: ${processPeople( pkg.maintainers )}`
		: ''
}
`

	const templateMark = `# Automatically generated by "${name}". Please do not edit manually.`

	const REPO_URL = getPackageRepoUrlFromContent( pkg )
	if ( !REPO_URL ) throw new Error( 'Repository URL must exists in "pkg" constant' )

	const _coreURL = getPackageRepoUrlFromContent( corePkg, { dir: false } )
	const _coreDir = typeof corePkg.repository === 'object' ? ( corePkg.repository.directory || '' ) : ''

	const REPO_CORE_URL = _coreURL || REPO_URL
		? joinUrl( _coreURL || REPO_URL, 'tree/main', _coreURL ? _coreDir : '' )
		: undefined
	if ( !REPO_CORE_URL ) throw new Error( 'Repository URL must exists in "corePkg" constant' )

	return {
		name  : `${name.toUpperCase()} WORKSPACE`,
		desc  : `Workspace tools for ${name} repository that uses the "dovenv" core and "pigeonposse" theme`,
		const : {
			name,
			workspaceDir,
			wsDir     : workspaceDir,
			packagesDir,
			pkg,
			corePkg,
			coreDir,
			mark,
			templateMark,
			REPO_URL,
			REPO_CORE_URL,
			pkgBadges : pkgBadges( {
				pkgName  : pkg.extra?.libraryId || pkg.extra?.libraryID || name,
				repoName : pkg.extra?.collective?.id + '/' + ( pkg.extra?.repoID || pkg.extra?.repoId ),
			} ),
			socialBadges : 'extra' in pkg && pkg.extra?.collective
				? socialBadges( {
					...pkg.extra.collective.social || {},
					web    : pkg.extra.collective.web,
					about  : pkg.extra.collective.about,
					donate : pkg.extra.collective.funding,
				} )
				: '',
		},
	}

}

